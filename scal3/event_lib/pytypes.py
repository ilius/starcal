from __future__ import annotations

from typing import (
	IO,
	TYPE_CHECKING,
	Any,
	NotRequired,
	Protocol,
	Self,
	TypedDict,
	runtime_checkable,
)

if TYPE_CHECKING:
	from collections.abc import Callable, Iterator, Sequence
	from datetime import tzinfo

	from scal3.color_utils import ColorType
	from scal3.event_search_tree import EventSearchTree
	from scal3.filesystem import FileSystem
	from scal3.s_object import ParentSObj
	from scal3.time_utils import HMS

	from .groups_import import EventGroupsImportResult


__all__ = [
	"AccountType",
	"BaseClassType",
	"EventContainerType",
	"EventGroupType",
	"EventNotifierType",
	"EventRuleType",
	"EventSearchConditionDict",
	"EventType",
	"OccurSetType",
	"RuleContainerType",
]


class BaseClassType(Protocol):
	name: str
	tname: str
	desc: str
	nameAlias: str
	WidgetClass: Any
	fs: FileSystem


class BaseTextModelType(Protocol):
	name: str
	tname: str
	desc: str
	nameAlias: str
	WidgetClass: Any
	fs: FileSystem


class OccurSetType(Protocol):
	event: EventType | None

	def intersection(self, other: OccurSetType) -> OccurSetType: ...
	# def getDaysJdList(self) -> list[int]: ...
	def getTimeRangeList(self) -> list[tuple[int, int]]: ...
	def getStartJd(self) -> int | None: ...
	def getEndJd(self) -> int | None: ...


class RuleContainerType(BaseClassType, Protocol):
	calType: int
	rulesDict: dict[str, EventRuleType]

	def __getitem__(self, key: str) -> EventRuleType | None: ...
	def getTimeZoneObj(self) -> tzinfo: ...
	def getJhmsFromEpoch(self, epoch: int) -> tuple[int, HMS]: ...
	def getEpochFromJhms(self, jd: int, h: int, m: int, s: int) -> int: ...
	def getRule(self, key: str) -> EventRuleType | None: ...
	def getAddRule(self, ruleType: str) -> EventRuleType: ...
	def setDict(self, data: dict[str, Any]) -> None: ...
	def getDict(self) -> dict[str, Any]: ...


class EventRuleType(BaseClassType, Protocol):
	provide: Sequence[str]
	need: Sequence[str]
	conflict: Sequence[str]
	sgroup: int
	expand: bool

	def __init__(self, parent: RuleContainerType) -> None: ...
	def getEpoch(self) -> int: ...
	def getRuleValue(self) -> Any: ...
	def setRuleValue(self, data: Any) -> None: ...
	def calcOccurrence(
		self,
		startJd: int,
		endJd: int,
		event: EventType,
	) -> OccurSetType: ...
	def changeCalType(self, calType: int) -> bool: ...
	def getJd(self) -> int: ...
	def getInfo(self) -> str: ...
	def getServerString(self) -> str: ...

	@classmethod
	def getFrom(cls, container: RuleContainerType) -> Self | None: ...
	@classmethod
	def addOrGetFrom(cls, container: RuleContainerType) -> Self: ...


class EventNotifierType(BaseClassType, Protocol):
	extraMessage: str
	event: EventType

	def __init__(self, event: EventType) -> None: ...
	def notify(self, finishFunc: Callable[[], None]) -> None: ...
	def setDict(self, data: dict[str, Any]) -> None: ...
	def getDict(self) -> dict[str, Any]: ...


class EventType(RuleContainerType, Protocol):
	id: int | None
	uuid: str | None
	parent: EventContainerType | None
	calType: int
	timeZone: str
	timeZoneEnable: bool
	lastHash: str | None
	modified: float
	rulesHash: int | None
	isSingleOccur: bool
	remoteIds: tuple[int, str, str, str] | None
	notifiers: list[EventNotifierType]
	notifyBefore: tuple[float, int]
	icon: str | None
	summary: str
	description: str
	isAllDay: bool
	readOnly: bool

	def setDict(self, data: dict[str, Any]) -> None: ...
	def getDict(self) -> dict[str, Any]: ...
	def getV4Dict(self) -> dict[str, Any]: ...

	@classmethod
	def getDefaultIcon(cls) -> str: ...

	def save(self) -> None: ...
	def copyFrom(self, other: EventType) -> None: ...
	def copyFromExact(self, other: EventType) -> None: ...
	def getStartJd(self) -> int: ...
	def getStartEpoch(self) -> int: ...
	def checkNotify(self, finishFunc: Callable[[], None]) -> None: ...
	def __init__(
		self,
		ident: int | None = None,
		parent: EventContainerType | None = None,
	) -> None: ...
	def getRulesHash(self) -> int: ...
	def getTextParts(self, showDesc: bool = True) -> list[str]: ...
	def getIconRel(self) -> str | None: ...
	def getInfo(self) -> str: ...
	def afterModify(self) -> None: ...
	def afterModifyBasic(self) -> None: ...
	def afterModifyInGroup(self) -> None: ...
	def changeCalType(self, calType: int) -> bool: ...
	def setId(self, ident: int | None = None) -> None: ...
	def calcEventOccurrenceIn(self, startJd: int, endJd: int) -> OccurSetType: ...
	def calcEventOccurrence(self) -> OccurSetType: ...
	def getNotifyBeforeSec(self) -> float: ...
	def getSummary(self) -> str: ...
	def getDescription(self) -> str: ...
	def getText(self, showDesc: bool = True) -> str: ...
	def icsUID(self) -> str: ...
	def getIcsData(
		self,
		prettyDateTime: bool = False,
	) -> list[tuple[str, str]] | None: ...
	def getDictOrdered(self) -> dict[str, Any]: ...
	def setDictOverride(self, data: dict[str, Any]) -> None: ...
	def loadHistory(self) -> list[tuple[int, str]]: ...
	def createPatchByHash(self, oldHash: str) -> dict[str, Any]: ...
	def getEndEpoch(self) -> int: ...
	def getJd(self) -> int: ...
	def getEndJd(self) -> int: ...
	def updateSummary(self) -> None: ...
	def getRevision(self, revHash: str, ident: int = 0) -> Self: ...
	def setJd(self, jd: int) -> None: ...
	def invalidate(self) -> None: ...
	def clearRules(self) -> None: ...
	def addRule(self, rule: EventRuleType) -> None: ...
	def checkRulesDependencies(
		self,
		newRule: EventRuleType | None = None,
		disabledRule: EventRuleType | None = None,
	) -> tuple[bool, str]: ...
	def checkAndRemoveRule(self, rule: EventRuleType) -> tuple[bool, str]: ...
	def create(self, ruleName: str) -> EventRuleType: ...
	def checkAndAddRule(self, rule: EventRuleType) -> tuple[bool, str]: ...
	def getIcon(self) -> str | None: ...
	def getShownDescription(self) -> str: ...
	def getNotifyBeforeMin(self) -> int: ...
	def setIcsData(self, data: dict[str, str]) -> bool: ...


class EventContainerType(BaseTextModelType, Protocol):
	title: str
	calType: int
	showFullEventDesc: bool
	idList: list[int]
	eventTextSep: str
	startJd: int
	endJd: int
	occur: EventSearchTree | None

	def __len__(self) -> int: ...
	def __iter__(self) -> Iterator[EventType]: ...
	def index(self, ident: int) -> int: ...
	def getIdPath(self) -> list[int]: ...
	def getPath(self) -> list[int]: ...
	def updateOccurrenceEvent(self, event: EventType) -> None: ...
	def getStartEpoch(self) -> int: ...
	def getEndEpoch(self) -> int: ...
	def getTimeZoneStr(self) -> str: ...


class EventGroupType(EventContainerType, Protocol):
	id: int | None
	uuid: str | None
	file: str
	enable: bool
	parent: ParentSObj | None
	color: ColorType
	icon: str | None
	modified: float
	actions: list[tuple[str, str]]
	acceptsEventTypes: Sequence[str]
	canConvertTo: list[str]
	notificationEnabled: bool
	notifyOccur: EventSearchTree | None = None
	remoteIds: tuple[int, str] | None
	occurCount: int
	showInDCal: bool
	showInWCal: bool
	showInMCal: bool
	showInStatusIcon: bool
	showInTimeLine: bool
	deletedRemoteEvents: dict[int, tuple[float, int, str, str]]
	addEventsToBeginning: bool

	@classmethod
	def load(
		cls,
		ident: int,
		fs: FileSystem,
	) -> EventGroupType | None: ...

	@property
	def mustId(self) -> int: ...

	def setDict(self, data: dict[str, Any]) -> None: ...
	def getDict(self) -> dict[str, Any]: ...
	def save(self) -> None: ...
	def getEvent(self, ident: int) -> EventType: ...
	def setId(self, ident: int | None = None) -> None: ...
	def afterModify(self) -> None: ...
	def create(self, eventType: str) -> EventType: ...
	def append(self, event: EventType) -> None: ...
	def removeAll(self) -> None: ...
	def remove(self, event: EventType) -> int: ...
	def setRandomColor(self) -> None: ...
	def setTitle(self, title: str) -> None: ...
	def deepConvertTo(self, newGroupType: str) -> EventGroupType: ...
	def exportData(self) -> dict[str, Any]: ...
	def getLastSync(self) -> tuple[float, float] | None: ...
	def getStartEpoch(self) -> int: ...
	def setReadOnly(self, readOnly: bool) -> None: ...
	def afterSync(self, startEpoch: float | None = None) -> None: ...
	def getSortBys(self) -> tuple[str, list[tuple[str, str, bool]]]: ...
	def sort(self, attr: str = "summary", reverse: bool = False) -> None: ...
	def __iter__(self) -> Iterator[EventType]: ...
	def updateOccurrence(self) -> None: ...
	def importData(
		self,
		data: dict[str, Any],
		importMode: int,
	) -> EventGroupsImportResult: ...
	def exportToIcsFp(self, fp: IO[str]) -> None: ...
	def __getitem__(self, ident: int) -> EventType: ...
	def showInCal(self) -> bool: ...
	def index(self, ident: int) -> int: ...
	def search(self, conds: EventSearchConditionDict) -> Iterator[EventType]: ...
	def __len__(self) -> int: ...
	def checkEventToAdd(self, event: EventType) -> bool: ...
	def isReadOnly(self) -> bool: ...
	def deepCopy(self) -> EventGroupType: ...
	def moveUp(self, index: int) -> None: ...
	def moveDown(self, index: int) -> None: ...
	def insert(self, index: int, event: EventType) -> None: ...
	def updateCache(self, event: EventType) -> None: ...


@runtime_checkable
class AccountType(BaseTextModelType, Protocol):
	id: int | None
	uuid: str | None
	file: str
	enable: bool
	title: str
	loaded: bool
	remoteGroups: list[dict[str, Any]]

	@classmethod
	def load(
		cls,
		ident: int,
		fs: FileSystem,
	) -> AccountType | None: ...

	def __init__(self, ident: int | None = None) -> None: ...
	def setId(self, ident: int | None = None) -> None: ...
	def setDict(self, data: dict[str, Any]) -> None: ...
	def getDict(self) -> dict[str, Any]: ...
	def save(self) -> None: ...
	def fetchGroups(self) -> None: ...
	def sync(
		self,
		group: EventGroupType,
		remoteGroupId: str,
	) -> None: ...


class EventSearchConditionDict(TypedDict):
	text: NotRequired[str]
	text_lower: NotRequired[str]
	time_from: NotRequired[int]
	time_to: NotRequired[int]
	modified_from: NotRequired[int]
	type: NotRequired[str]
	timezone: NotRequired[str]
